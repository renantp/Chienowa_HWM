RL78 Family Assembler V1.10.00.01 Assemble Source List

OFFSET   CODE                  NO  SOURCE STATEMENT

00000000                        1  #CC-RL Compiler RL78 Assembler Source
00000000                        2  #@  CC-RL Version : V1.10.00 [20 Nov 2020]
00000000                        3  #@  Commmand :
00000000                        4  #@   -cpu=S3
00000000                        5  #@   -c
00000000                        6  #@   -dev=D:/Chieniwa/E2_Studio/.eclipse/com.renesas.platform_1435879475/DebugComp/RL78/RL78/Common/DR5F104ML.DVF
00000000                        7  #@   -MAKEUD=D:\Chieniwa\E2_Studio\ControlPCB_HWM\HardwareDebug\src
00000000                        8  #@   -I C:\Program Files (x86)\Renesas Electronics\CS+\CC\CC-RL\V1.10.00\inc
00000000                        9  #@   -I D:\Chieniwa\E2_Studio\ControlPCB_HWM\generate
00000000                       10  #@   -character_set=utf8
00000000                       11  #@   -lang=c99
00000000                       12  #@   -g
00000000                       13  #@   -asmopt=-prn_path=src
00000000                       14  #@   -asm_path=src/
00000000                       15  #@   -pass_source
00000000                       16  #@   -o src/r_cg_serial_user.obj
00000000                       17  #@   ../src/r_cg_serial_user.c
00000000                       18  #@  compiled at Thu Feb 10 14:43:53 2022
00000000                       19  
00000000                       20  	.PUBLIC _g_uart3_rx_data
00000000                       21  	.EXTERN _gp_uart1_tx_address
00000000                       22  	.EXTERN _g_uart1_tx_count
00000000                       23  	.EXTERN _gp_uart1_rx_address
00000000                       24  	.EXTERN _g_uart1_rx_count
00000000                       25  	.EXTERN _g_uart1_rx_length
00000000                       26  	.EXTERN _gp_csi00_tx_address
00000000                       27  	.EXTERN _g_csi00_tx_count
00000000                       28  	.EXTERN _gp_csi01_rx_address
00000000                       29  	.EXTERN _gp_csi01_tx_address
00000000                       30  	.EXTERN _g_csi01_tx_count
00000000                       31  	.EXTERN _gp_uart2_tx_address
00000000                       32  	.EXTERN _g_uart2_tx_count
00000000                       33  	.EXTERN _gp_uart2_rx_address
00000000                       34  	.EXTERN _g_uart2_rx_count
00000000                       35  	.EXTERN _g_uart2_rx_length
00000000                       36  	.EXTERN _gp_uart3_tx_address
00000000                       37  	.EXTERN _g_uart3_tx_count
00000000                       38  	.EXTERN _gp_uart3_rx_address
00000000                       39  	.EXTERN _g_uart3_rx_count
00000000                       40  	.EXTERN _g_uart3_rx_length
00000000                       41  	.PUBLIC _send_response_flag
00000000                       42  	.PUBLIC _send_response_time_flag
00000000                       43  	.PUBLIC _send_response_number_flag
00000000                       44  	.PUBLIC _recived_time_setting_flag
00000000                       45  	.PUBLIC _send_respone_status_flag
00000000                       46  	.PUBLIC _recived_number_setting_flag
00000000                       47  	.PUBLIC _g_commnunication_flag
00000000                       48  	.PUBLIC _g_csi_count
00000000                       49  	.PUBLIC _g_csi_err
00000000                       50  	.PUBLIC _g_csi_send_end
00000000                       51  	.PUBLIC _g_csi_rev_end
00000000                       52  	.PUBLIC _g_uart1_send
00000000                       53  	.PUBLIC _g_uart2_sendend
00000000                       54  	.PUBLIC _g_uart2_receive
00000000                       55  	.PUBLIC _g_rx_data
00000000                       56  	.PUBLIC _g_uart2_fault
00000000                       57  	.PUBLIC _g_uart3_sendend
00000000                       58  	.EXTERN _R_CSI01_Stop
00000000                       59  	.EXTERN _uart2_handle
00000000                       60  	.EXTERN _R_UART3_Receive
00000000                       61  
00000000                       62  	.SECTION .text,TEXT
00000000                       63  _r_uart1_interrupt_receive@1	.vector 0x0026
00000000                       64  _r_uart1_interrupt_receive@1:
00000000                       65  	.STACK _r_uart1_interrupt_receive@1 = 16
00000000                       66  	;***        1 : /***********************************************************************************************************************
00000000                       67  	;***        2 :  * DISCLAIMER
00000000                       68  	;***        3 :  * This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products.
00000000                       69  	;***        4 :  * No other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
00000000                       70  	;***        5 :  * applicable laws, including copyright laws.
00000000                       71  	;***        6 :  * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING THIS SOFTWARE, WHETHER EXPRESS, IMPLIED
00000000                       72  	;***        7 :  * OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
00000000                       73  	;***        8 :  * NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY
00000000                       74  	;***        9 :  * LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE FOR ANY DIRECT,
00000000                       75  	;***       10 :  * INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR
00000000                       76  	;***       11 :  * ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
00000000                       77  	;***       12 :  * Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability
00000000                       78  	;***       13 :  * of this software. By using this software, you agree to the additional terms and conditions found by accessing the
00000000                       79  	;***       14 :  * following link:
00000000                       80  	;***       15 :  * http://www.renesas.com/disclaimer
00000000                       81  	;***       16 :  *
00000000                       82  	;***       17 :  * Copyright (C) 2011, 2020 Renesas Electronics Corporation. All rights reserved.
00000000                       83  	;***       18 :  ***********************************************************************************************************************/
00000000                       84  	;***       19 : 
00000000                       85  	;***       20 : /***********************************************************************************************************************
00000000                       86  	;***       21 :  * File Name    : r_cg_serial_user.c
00000000                       87  	;***       22 :  * Version      : CodeGenerator for RL78/G14 V2.05.05.01 [25 Nov 2020]
00000000                       88  	;***       23 :  * Device(s)    : R5F104ML
00000000                       89  	;***       24 :  * Tool-Chain   : CCRL
00000000                       90  	;***       25 :  * Description  : This file implements device driver for Serial module.
00000000                       91  	;***       26 :  * Creation Date: 30/11/2021
00000000                       92  	;***       27 :  ***********************************************************************************************************************/
00000000                       93  	;***       28 : 
00000000                       94  	;***       29 : /***********************************************************************************************************************
00000000                       95  	;***       30 :  Includes
00000000                       96  	;***       31 :  ***********************************************************************************************************************/
00000000                       97  	;***       32 : #include "hwm/main.h"
00000000                       98  	;***       33 : #include "r_cg_macrodriver.h"
00000000                       99  	;***       34 : #include "r_cg_serial.h"
00000000                      100  	;***       35 : /* Start user code for include. Do not edit comment generated here */
00000000                      101  	;***       36 : #include "r_cg_wdt.h"
00000000                      102  	;***       37 : #include "r_cg_userdefine.h"
00000000                      103  	;***       38 : 
00000000                      104  	;***       39 : /***********************************************************************************************************************
00000000                      105  	;***       40 :  Pragma directive
00000000                      106  	;***       41 :  ***********************************************************************************************************************/
00000000                      107  	;***       42 : #pragma interrupt r_uart1_interrupt_send(vect=INTST1)
00000000                      108  	;***       43 : #pragma interrupt r_uart1_interrupt_receive(vect=INTSR1)
00000000                      109  	;***       44 : #pragma interrupt r_csi00_interrupt(vect=INTCSI00)
00000000                      110  	;***       45 : #pragma interrupt r_csi01_interrupt(vect=INTCSI01)
00000000                      111  	;***       46 : #pragma interrupt r_uart2_interrupt_send(vect=INTST2)
00000000                      112  	;***       47 : #pragma interrupt r_uart2_interrupt_receive(vect=INTSR2)
00000000                      113  	;***       48 : #pragma interrupt r_uart3_interrupt_send(vect=INTST3)
00000000                      114  	;***       49 : #pragma interrupt r_uart3_interrupt_receive(vect=INTSR3)
00000000                      115  	;***       50 : /* Start user code for pragma. Do not edit comment generated here */
00000000                      116  	;***       51 : /* End user code. Do not edit comment generated here */
00000000                      117  	;***       52 : 
00000000                      118  	;***       53 : /***********************************************************************************************************************
00000000                      119  	;***       54 :  Global variables and functions
00000000                      120  	;***       55 :  ***********************************************************************************************************************/
00000000                      121  	;***       56 : extern volatile uint8_t *gp_uart1_tx_address; /* uart1 send buffer address */
00000000                      122  	;***       57 : extern volatile uint16_t g_uart1_tx_count; /* uart1 send data number */
00000000                      123  	;***       58 : extern volatile uint8_t *gp_uart1_rx_address; /* uart1 receive buffer address */
00000000                      124  	;***       59 : extern volatile uint16_t g_uart1_rx_count; /* uart1 receive data number */
00000000                      125  	;***       60 : extern volatile uint16_t g_uart1_rx_length; /* uart1 receive data length */
00000000                      126  	;***       61 : extern volatile uint8_t *gp_csi00_rx_address; /* csi00 receive buffer address */
00000000                      127  	;***       62 : extern volatile uint16_t g_csi00_rx_length; /* csi00 receive data length */
00000000                      128  	;***       63 : extern volatile uint16_t g_csi00_rx_count; /* csi00 receive data count */
00000000                      129  	;***       64 : extern volatile uint8_t *gp_csi00_tx_address; /* csi00 send buffer address */
00000000                      130  	;***       65 : extern volatile uint16_t g_csi00_send_length; /* csi00 send data length */
00000000                      131  	;***       66 : extern volatile uint16_t g_csi00_tx_count; /* csi00 send data count */
00000000                      132  	;***       67 : extern volatile uint8_t *gp_csi01_rx_address; /* csi01 receive buffer address */
00000000                      133  	;***       68 : extern volatile uint16_t g_csi01_rx_length; /* csi01 receive data length */
00000000                      134  	;***       69 : extern volatile uint16_t g_csi01_rx_count; /* csi01 receive data count */
00000000                      135  	;***       70 : extern volatile uint8_t *gp_csi01_tx_address; /* csi01 send buffer address */
00000000                      136  	;***       71 : extern volatile uint16_t g_csi01_send_length; /* csi01 send data length */
00000000                      137  	;***       72 : extern volatile uint16_t g_csi01_tx_count; /* csi01 send data count */
00000000                      138  	;***       73 : extern volatile uint8_t *gp_uart2_tx_address; /* uart2 send buffer address */
00000000                      139  	;***       74 : extern volatile uint16_t g_uart2_tx_count; /* uart2 send data number */
00000000                      140  	;***       75 : extern volatile uint8_t *gp_uart2_rx_address; /* uart2 receive buffer address */
00000000                      141  	;***       76 : extern volatile uint16_t g_uart2_rx_count; /* uart2 receive data number */
00000000                      142  	;***       77 : extern volatile uint16_t g_uart2_rx_length; /* uart2 receive data length */
00000000                      143  	;***       78 : extern volatile uint8_t *gp_uart3_tx_address; /* uart3 send buffer address */
00000000                      144  	;***       79 : extern volatile uint16_t g_uart3_tx_count; /* uart3 send data number */
00000000                      145  	;***       80 : extern volatile uint8_t *gp_uart3_rx_address; /* uart3 receive buffer address */
00000000                      146  	;***       81 : extern volatile uint16_t g_uart3_rx_count; /* uart3 receive data number */
00000000                      147  	;***       82 : extern volatile uint16_t g_uart3_rx_length; /* uart3 receive data length */
00000000                      148  	;***       83 : /* Start user code for global. Do not edit comment generated here */
00000000                      149  	;***       84 : volatile uint8_t send_response_flag, send_response_time_flag,
00000000                      150  	;***       85 : 		send_response_number_flag, recived_time_setting_flag,
00000000                      151  	;***       86 : 		send_respone_status_flag, recived_number_setting_flag;
00000000                      152  	;***       87 : volatile struct Communicaition_flag_s g_commnunication_flag;
00000000                      153  	;***       88 : volatile uint8_t g_csi_count, g_csi_err, g_csi_send_end, g_csi_rev_end,
00000000                      154  	;***       89 : 		g_uart1_send, g_uart2_sendend, g_uart2_receive;
00000000                      155  	;***       90 : uint8_t g_rx_data[4 * 40];
00000000                      156  	;***       91 : uint8_t g_uart3_rx_data[8];
00000000                      157  	;***       92 : volatile uint8_t g_uart2_fault;
00000000                      158  	;***       93 : volatile uint8_t g_uart3_sendend;
00000000                      159  	;***       94 : 
00000000                      160  	;***       95 : /* End user code. Do not edit comment generated here */
00000000                      161  	;***       96 : 
00000000                      162  	;***       97 : /***********************************************************************************************************************
00000000                      163  	;***       98 :  * Function Name: r_uart1_interrupt_receive
00000000                      164  	;***       99 :  * Description  : This function is INTSR1 interrupt service routine.
00000000                      165  	;***      100 :  * Arguments    : None
00000000                      166  	;***      101 :  * Return Value : None
00000000                      167  	;***      102 :  ***********************************************************************************************************************/
00000000                      168  	;***      103 : static void __near r_uart1_interrupt_receive(void) {
00000000                      169  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 103
00000000 C1                   170  	push ax
00000001 C3                   171  	push bc
00000002 C5                   172  	push de
00000003 C7                   173  	push hl
00000004 8EFD                 174  	mov a, es
00000006 70                   175  	mov x, a
00000007 8EFC                 176  	mov a, cs
00000009 C1                   177  	push ax
0000000A C7                   178  	push hl
0000000B                      179  	;***      104 : 	volatile uint8_t rx_data;
0000000B                      180  	;***      105 : 	volatile uint8_t err_type;
0000000B                      181  	;***      106 : 
0000000B                      182  	;***      107 : 	err_type = (uint8_t) (SSR03 & 0x0007U);
0000000B                      183  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 107
0000000B AF0601               184  	movw ax, !0x0106
0000000E 60                   185  	mov a, x
0000000F 5C07                 186  	and a, #0x07
00000011 9800                 187  	mov [sp+0x00], a
00000013                      188  	;***      108 : 	SIR03 = (uint16_t) err_type;
00000013                      189  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 108
00000013 8800                 190  	mov a, [sp+0x00]
00000015 318E                 191  	shrw ax, 8+0x00000
00000017 BF0E01               192  	movw !0x010E, ax
0000001A                      193  	;***      109 : 
0000001A                      194  	;***      110 : 	if (err_type != 0U) {
0000001A                      195  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 110
0000001A 8800                 196  	mov a, [sp+0x00]
0000001C D1                   197  	cmp0 a
0000001D DD00                 198  	bz $.BB@LABEL@1_2
0000001F                      199  .BB@LABEL@1_1:	; if_then_bb
0000001F                      200  	;***      111 : 		r_uart1_callback_error(err_type);
0000001F                      201  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 111
0000001F 8800                 202  	mov a, [sp+0x00]
00000021 FC000000             203  	call !!_r_uart1_callback_error@1
00000025                      204  .BB@LABEL@1_2:	; if_break_bb
00000025                      205  	;***      112 : 	}
00000025                      206  	;***      113 : 
00000025                      207  	;***      114 : 	rx_data = RXD1;
00000025                      208  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 114
00000025 8E46                 209  	mov a, 0xFFF46
00000027 9801                 210  	mov [sp+0x01], a
00000029                      211  	;***      115 : 
00000029                      212  	;***      116 : 	if (g_uart1_rx_length > g_uart1_rx_count) {
00000029                      213  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 116
00000029 AF0000               214  	movw ax, !LOWW(_g_uart1_rx_length)
0000002C 420000               215  	cmpw ax, !LOWW(_g_uart1_rx_count)
0000002F 8801                 216  	mov a, [sp+0x01]
00000031 61D300               217  	bnh $.BB@LABEL@1_6
00000034                      218  .BB@LABEL@1_3:	; if_then_bb18
00000034                      219  	;***      117 : 		*gp_uart1_rx_address = rx_data;
00000034                      220  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 117
00000034 EB0000               221  	movw de, !LOWW(_gp_uart1_rx_address)
00000037 99                   222  	mov [de], a
00000038                      223  	;***      118 : 		gp_uart1_rx_address++;
00000038                      224  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 118
00000038 A20000               225  	incw !LOWW(_gp_uart1_rx_address)
0000003B                      226  	;***      119 : 		g_uart1_rx_count++;
0000003B                      227  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 119
0000003B A20000               228  	incw !LOWW(_g_uart1_rx_count)
0000003E                      229  	;***      120 : 
0000003E                      230  	;***      121 : 		if (g_uart1_rx_length == g_uart1_rx_count) {
0000003E                      231  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 121
0000003E AF0000               232  	movw ax, !LOWW(_g_uart1_rx_length)
00000041 420000               233  	cmpw ax, !LOWW(_g_uart1_rx_count)
00000044 61F8                 234  	sknz
00000046                      235  .BB@LABEL@1_4:	; if_then_bb30
00000046                      236  	;***      122 : 			r_uart1_callback_receiveend();
00000046                      237  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 122
00000046 FC000000             238  	call !!_r_uart1_callback_receiveend@1
0000004A                      239  .BB@LABEL@1_5:	; return
0000004A C6                   240  	pop hl
0000004B C0                   241  	pop ax
0000004C 9EFC                 242  	mov cs, a
0000004E 60                   243  	mov a, x
0000004F 9EFD                 244  	mov es, a
00000051 C6                   245  	pop hl
00000052 C4                   246  	pop de
00000053 C2                   247  	pop bc
00000054 C0                   248  	pop ax
00000055                      249  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 127
00000055 61FC                 250  	reti
00000057                      251  .BB@LABEL@1_6:	; if_else_bb
00000057                      252  	;***      123 : 		}
00000057                      253  	;***      124 : 	} else {
00000057                      254  	;***      125 : 		r_uart1_callback_softwareoverrun(rx_data);
00000057                      255  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 125
00000057 318E                 256  	shrw ax, 8+0x00000
00000059 FC000000             257  	call !!_r_uart1_callback_softwareoverrun@1
0000005D EF00                 258  	br $.BB@LABEL@1_5
0000005F                      259  _r_uart1_interrupt_send@1	.vector 0x0024
0000005F                      260  _r_uart1_interrupt_send@1:
0000005F                      261  	.STACK _r_uart1_interrupt_send@1 = 14
0000005F                      262  	;***      126 : 	}
0000005F                      263  	;***      127 : }
0000005F                      264  	;***      128 : 
0000005F                      265  	;***      129 : /***********************************************************************************************************************
0000005F                      266  	;***      130 :  * Function Name: r_uart1_interrupt_send
0000005F                      267  	;***      131 :  * Description  : This function is INTST1 interrupt service routine.
0000005F                      268  	;***      132 :  * Arguments    : None
0000005F                      269  	;***      133 :  * Return Value : None
0000005F                      270  	;***      134 :  ***********************************************************************************************************************/
0000005F                      271  	;***      135 : static void __near r_uart1_interrupt_send(void) {
0000005F                      272  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 135
0000005F C1                   273  	push ax
00000060 C3                   274  	push bc
00000061 C5                   275  	push de
00000062 C7                   276  	push hl
00000063 8EFD                 277  	mov a, es
00000065 70                   278  	mov x, a
00000066 8EFC                 279  	mov a, cs
00000068 C1                   280  	push ax
00000069                      281  	;***      136 : 	if (g_uart1_tx_count > 0U) {
00000069                      282  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 136
00000069 AF0000               283  	movw ax, !LOWW(_g_uart1_tx_count)
0000006C F7                   284  	clrw bc
0000006D 43                   285  	cmpw ax, bc
0000006E DF00                 286  	bnz $.BB@LABEL@2_3
00000070                      287  .BB@LABEL@2_1:	; if_else_bb
00000070                      288  	;***      137 : 		TXD1 = *gp_uart1_tx_address;
00000070                      289  	;***      138 : 		gp_uart1_tx_address++;
00000070                      290  	;***      139 : 		g_uart1_tx_count--;
00000070                      291  	;***      140 : 	} else {
00000070                      292  	;***      141 : 		r_uart1_callback_sendend();
00000070                      293  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 141
00000070 FC000000             294  	call !!_r_uart1_callback_sendend@1
00000074                      295  .BB@LABEL@2_2:	; if_else_bb
00000074 C0                   296  	pop ax
00000075 9EFC                 297  	mov cs, a
00000077 60                   298  	mov a, x
00000078 9EFD                 299  	mov es, a
0000007A C6                   300  	pop hl
0000007B C4                   301  	pop de
0000007C C2                   302  	pop bc
0000007D C0                   303  	pop ax
0000007E                      304  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 143
0000007E 61FC                 305  	reti
00000080                      306  .BB@LABEL@2_3:	; if_then_bb
00000080                      307  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 137
00000080 EB0000               308  	movw de, !LOWW(_gp_uart1_tx_address)
00000083 89                   309  	mov a, [de]
00000084 9E44                 310  	mov 0xFFF44, a
00000086                      311  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 138
00000086 A5                   312  	incw de
00000087 15                   313  	movw ax, de
00000088 BF0000               314  	movw !LOWW(_gp_uart1_tx_address), ax
0000008B                      315  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 139
0000008B B20000               316  	decw !LOWW(_g_uart1_tx_count)
0000008E EF00                 317  	br $.BB@LABEL@2_2
00000000                      318  	.SECTION .textf,TEXTF
00000000                      319  _r_uart1_callback_receiveend@1:
00000000                      320  	.STACK _r_uart1_callback_receiveend@1 = 4
00000000                      321  	;***      142 : 	}
00000000                      322  	;***      143 : }
00000000                      323  	;***      144 : 
00000000                      324  	;***      145 : /***********************************************************************************************************************
00000000                      325  	;***      146 :  * Function Name: r_uart1_callback_receiveend
00000000                      326  	;***      147 :  * Description  : This function is a callback function when UART1 finishes reception.
00000000                      327  	;***      148 :  * Arguments    : None
00000000                      328  	;***      149 :  * Return Value : None
00000000                      329  	;***      150 :  ***********************************************************************************************************************/
00000000                      330  	;***      151 : static void r_uart1_callback_receiveend(void) {
00000000                      331  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 151
00000000 D7                   332  	ret
00000001                      333  _r_uart1_callback_softwareoverrun@1:
00000001                      334  	.STACK _r_uart1_callback_softwareoverrun@1 = 4
00000001                      335  	;***      152 : 	/* Start user code. Do not edit comment generated here */
00000001                      336  	;***      153 : 	/* End user code. Do not edit comment generated here */
00000001                      337  	;***      154 : }
00000001                      338  	;***      155 : 
00000001                      339  	;***      156 : /***********************************************************************************************************************
00000001                      340  	;***      157 :  * Function Name: r_uart1_callback_softwareoverrun
00000001                      341  	;***      158 :  * Description  : This function is a callback function when UART1 receives an overflow data.
00000001                      342  	;***      159 :  * Arguments    : rx_data -
00000001                      343  	;***      160 :  *                    receive data
00000001                      344  	;***      161 :  * Return Value : None
00000001                      345  	;***      162 :  ***********************************************************************************************************************/
00000001                      346  	;***      163 : static void r_uart1_callback_softwareoverrun(uint16_t rx_data) {
00000001                      347  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 163
00000001 D7                   348  	ret
00000002                      349  _r_uart1_callback_sendend@1:
00000002                      350  	.STACK _r_uart1_callback_sendend@1 = 4
00000002                      351  	;***      164 : 	/* Start user code. Do not edit comment generated here */
00000002                      352  	;***      165 : 	/* End user code. Do not edit comment generated here */
00000002                      353  	;***      166 : }
00000002                      354  	;***      167 : 
00000002                      355  	;***      168 : /***********************************************************************************************************************
00000002                      356  	;***      169 :  * Function Name: r_uart1_callback_sendend
00000002                      357  	;***      170 :  * Description  : This function is a callback function when UART1 finishes transmission.
00000002                      358  	;***      171 :  * Arguments    : None
00000002                      359  	;***      172 :  * Return Value : None
00000002                      360  	;***      173 :  ***********************************************************************************************************************/
00000002                      361  	;***      174 : static void r_uart1_callback_sendend(void) {
00000002                      362  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 174
00000002 D7                   363  	ret
00000003                      364  _r_uart1_callback_error@1:
00000003                      365  	.STACK _r_uart1_callback_error@1 = 4
00000003                      366  	;***      175 : 	/* Start user code. Do not edit comment generated here */
00000003                      367  	;***      176 : 	/* End user code. Do not edit comment generated here */
00000003                      368  	;***      177 : }
00000003                      369  	;***      178 : 
00000003                      370  	;***      179 : /***********************************************************************************************************************
00000003                      371  	;***      180 :  * Function Name: r_uart1_callback_error
00000003                      372  	;***      181 :  * Description  : This function is a callback function when UART1 reception error occurs.
00000003                      373  	;***      182 :  * Arguments    : err_type -
00000003                      374  	;***      183 :  *                    error type value
00000003                      375  	;***      184 :  * Return Value : None
00000003                      376  	;***      185 :  ***********************************************************************************************************************/
00000003                      377  	;***      186 : static void r_uart1_callback_error(uint8_t err_type) {
00000003                      378  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 186
00000003 D7                   379  	ret
00000090                      380  	.SECTION .text,TEXT
00000090                      381  _r_csi00_interrupt@1	.vector 0x001E
00000090                      382  _r_csi00_interrupt@1:
00000090                      383  	.STACK _r_csi00_interrupt@1 = 16
00000090                      384  	;***      187 : 	/* Start user code. Do not edit comment generated here */
00000090                      385  	;***      188 : 	/* End user code. Do not edit comment generated here */
00000090                      386  	;***      189 : }
00000090                      387  	;***      190 : 
00000090                      388  	;***      191 : /***********************************************************************************************************************
00000090                      389  	;***      192 :  * Function Name: r_csi00_interrupt
00000090                      390  	;***      193 :  * Description  : This function is INTCSI00 interrupt service routine.
00000090                      391  	;***      194 :  * Arguments    : None
00000090                      392  	;***      195 :  * Return Value : None
00000090                      393  	;***      196 :  ***********************************************************************************************************************/
00000090                      394  	;***      197 : static void __near r_csi00_interrupt(void) {
00000090                      395  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 197
00000090 C1                   396  	push ax
00000091 C3                   397  	push bc
00000092 C5                   398  	push de
00000093 C7                   399  	push hl
00000094 8EFD                 400  	mov a, es
00000096 70                   401  	mov x, a
00000097 8EFC                 402  	mov a, cs
00000099 C1                   403  	push ax
0000009A C7                   404  	push hl
0000009B                      405  	;***      198 : 	volatile uint8_t err_type;
0000009B                      406  	;***      199 : 
0000009B                      407  	;***      200 : 	err_type = (uint8_t) (SSR00 & _0001_SAU_OVERRUN_ERROR);
0000009B                      408  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 200
0000009B AF0001               409  	movw ax, !0x0100
0000009E 60                   410  	mov a, x
0000009F 5C01                 411  	and a, #0x01
000000A1 9800                 412  	mov [sp+0x00], a
000000A3                      413  	;***      201 : 	SIR00 = (uint16_t) err_type;
000000A3                      414  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 201
000000A3 8800                 415  	mov a, [sp+0x00]
000000A5 318E                 416  	shrw ax, 8+0x00000
000000A7 BF0801               417  	movw !0x0108, ax
000000AA                      418  	;***      202 : 
000000AA                      419  	;***      203 : 	if (err_type != 1U) {
000000AA                      420  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 203
000000AA 8800                 421  	mov a, [sp+0x00]
000000AC 91                   422  	dec a
000000AD DF00                 423  	bnz $.BB@LABEL@7_2
000000AF                      424  .BB@LABEL@7_1:	; return
000000AF C6                   425  	pop hl
000000B0 C0                   426  	pop ax
000000B1 9EFC                 427  	mov cs, a
000000B3 60                   428  	mov a, x
000000B4 9EFD                 429  	mov es, a
000000B6 C6                   430  	pop hl
000000B7 C4                   431  	pop de
000000B8 C2                   432  	pop bc
000000B9 C0                   433  	pop ax
000000BA                      434  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 212
000000BA 61FC                 435  	reti
000000BC                      436  .BB@LABEL@7_2:	; if_then_bb
000000BC                      437  	;***      204 : 		if (g_csi00_tx_count > 0U) {
000000BC                      438  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 204
000000BC AF0000               439  	movw ax, !LOWW(_g_csi00_tx_count)
000000BF F7                   440  	clrw bc
000000C0 43                   441  	cmpw ax, bc
000000C1 DF00                 442  	bnz $.BB@LABEL@7_4
000000C3                      443  .BB@LABEL@7_3:	; if_else_bb
000000C3                      444  	;***      205 : 			SIO00 = *gp_csi00_tx_address;
000000C3                      445  	;***      206 : 			gp_csi00_tx_address++;
000000C3                      446  	;***      207 : 			g_csi00_tx_count--;
000000C3                      447  	;***      208 : 		} else {
000000C3                      448  	;***      209 : 			r_csi00_callback_sendend(); /* complete send */
000000C3                      449  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 209
000000C3 FC000000             450  	call !!_r_csi00_callback_sendend@1
000000C7 EF00                 451  	br $.BB@LABEL@7_1
000000C9                      452  .BB@LABEL@7_4:	; if_then_bb14
000000C9                      453  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 205
000000C9 EB0000               454  	movw de, !LOWW(_gp_csi00_tx_address)
000000CC 89                   455  	mov a, [de]
000000CD 9D10                 456  	mov 0xFFF10, a
000000CF                      457  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 206
000000CF A5                   458  	incw de
000000D0 15                   459  	movw ax, de
000000D1 BF0000               460  	movw !LOWW(_gp_csi00_tx_address), ax
000000D4                      461  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 207
000000D4 B20000               462  	decw !LOWW(_g_csi00_tx_count)
000000D7 EF00                 463  	br $.BB@LABEL@7_1
00000004                      464  	.SECTION .textf,TEXTF
00000004                      465  _r_csi00_callback_sendend@1:
00000004                      466  	.STACK _r_csi00_callback_sendend@1 = 4
00000004                      467  	;***      210 : 		}
00000004                      468  	;***      211 : 	}
00000004                      469  	;***      212 : }
00000004                      470  	;***      213 : 
00000004                      471  	;***      214 : /***********************************************************************************************************************
00000004                      472  	;***      215 :  * Function Name: r_csi00_callback_sendend
00000004                      473  	;***      216 :  * Description  : This function is a callback function when CSI00 finishes transmission.
00000004                      474  	;***      217 :  * Arguments    : None
00000004                      475  	;***      218 :  * Return Value : None
00000004                      476  	;***      219 :  ***********************************************************************************************************************/
00000004                      477  	;***      220 : static void r_csi00_callback_sendend(void) {
00000004                      478  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 220
00000004 D7                   479  	ret
000000D9                      480  	.SECTION .text,TEXT
000000D9                      481  _r_csi01_interrupt@1	.vector 0x0020
000000D9                      482  _r_csi01_interrupt@1:
000000D9                      483  	.STACK _r_csi01_interrupt@1 = 16
000000D9                      484  	;***      221 : 	/* Start user code. Do not edit comment generated here */
000000D9                      485  	;***      222 : 	/* End user code. Do not edit comment generated here */
000000D9                      486  	;***      223 : }
000000D9                      487  	;***      224 : 
000000D9                      488  	;***      225 : /***********************************************************************************************************************
000000D9                      489  	;***      226 :  * Function Name: r_csi01_interrupt
000000D9                      490  	;***      227 :  * Description  : This function is INTCSI01 interrupt service routine.
000000D9                      491  	;***      228 :  * Arguments    : None
000000D9                      492  	;***      229 :  * Return Value : None
000000D9                      493  	;***      230 :  ***********************************************************************************************************************/
000000D9                      494  	;***      231 : static void __near r_csi01_interrupt(void) {
000000D9                      495  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 231
000000D9 C1                   496  	push ax
000000DA C3                   497  	push bc
000000DB C5                   498  	push de
000000DC C7                   499  	push hl
000000DD 8EFD                 500  	mov a, es
000000DF 70                   501  	mov x, a
000000E0 8EFC                 502  	mov a, cs
000000E2 C1                   503  	push ax
000000E3 C7                   504  	push hl
000000E4                      505  	;***      232 : 	volatile uint8_t err_type;
000000E4                      506  	;***      233 : 	volatile uint8_t sio_dummy;
000000E4                      507  	;***      234 : 
000000E4                      508  	;***      235 : 	err_type = (uint8_t) (SSR01 & _0001_SAU_OVERRUN_ERROR);
000000E4                      509  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 235
000000E4 AF0201               510  	movw ax, !0x0102
000000E7 60                   511  	mov a, x
000000E8 5C01                 512  	and a, #0x01
000000EA 9800                 513  	mov [sp+0x00], a
000000EC                      514  	;***      236 : 	SIR01 = (uint16_t) err_type;
000000EC                      515  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 236
000000EC 8800                 516  	mov a, [sp+0x00]
000000EE 318E                 517  	shrw ax, 8+0x00000
000000F0 BF0A01               518  	movw !0x010A, ax
000000F3                      519  	;***      237 : 
000000F3                      520  	;***      238 : 	if (1U == err_type) {
000000F3                      521  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 238
000000F3 8800                 522  	mov a, [sp+0x00]
000000F5 91                   523  	dec a
000000F6 DF00                 524  	bnz $.BB@LABEL@9_2
000000F8                      525  .BB@LABEL@9_1:	; if_then_bb
000000F8                      526  	;***      239 : 		r_csi01_callback_error(err_type); /* overrun error occurs */
000000F8                      527  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 239
000000F8 8800                 528  	mov a, [sp+0x00]
000000FA FC000000             529  	call !!_r_csi01_callback_error@1
000000FE EF00                 530  	br $.BB@LABEL@9_15
00000100                      531  .BB@LABEL@9_2:	; if_else_bb
00000100                      532  	;***      240 : 	} else {
00000100                      533  	;***      241 : 		if (g_csi01_tx_count > 0U) {
00000100                      534  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 241
00000100 AF0000               535  	movw ax, !LOWW(_g_csi01_tx_count)
00000103 F7                   536  	clrw bc
00000104 43                   537  	cmpw ax, bc
00000105 DF00                 538  	bnz $.BB@LABEL@9_8
00000107                      539  .BB@LABEL@9_3:	; if_else_bb42
00000107                      540  	;***      242 : 			if (0U != gp_csi01_rx_address) {
00000107                      541  	;***      243 : 				*gp_csi01_rx_address = SIO01;
00000107                      542  	;***      244 : 				gp_csi01_rx_address++;
00000107                      543  	;***      245 : 			} else {
00000107                      544  	;***      246 : 				sio_dummy = SIO01;
00000107                      545  	;***      247 : 			}
00000107                      546  	;***      248 : 
00000107                      547  	;***      249 : 			if (0U != gp_csi01_tx_address) {
00000107                      548  	;***      250 : 				SIO01 = *gp_csi01_tx_address;
00000107                      549  	;***      251 : 				gp_csi01_tx_address++;
00000107                      550  	;***      252 : 			} else {
00000107                      551  	;***      253 : 				SIO01 = 0xFFU;
00000107                      552  	;***      254 : 			}
00000107                      553  	;***      255 : 
00000107                      554  	;***      256 : 			g_csi01_tx_count--;
00000107                      555  	;***      257 : 		} else {
00000107                      556  	;***      258 : 			if (0U == g_csi01_tx_count) {
00000107                      557  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 258
00000107 AF0000               558  	movw ax, !LOWW(_g_csi01_tx_count)
0000010A 43                   559  	cmpw ax, bc
0000010B DF00                 560  	bnz $.BB@LABEL@9_7
0000010D                      561  .BB@LABEL@9_4:	; if_then_bb47
0000010D                      562  	;***      259 : 				if (0U != gp_csi01_rx_address) {
0000010D                      563  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 259
0000010D AF0000               564  	movw ax, !LOWW(_gp_csi01_rx_address)
00000110 43                   565  	cmpw ax, bc
00000111 DF00                 566  	bnz $.BB@LABEL@9_6
00000113                      567  .BB@LABEL@9_5:	; if_else_bb55
00000113                      568  	;***      260 : 					*gp_csi01_rx_address = SIO01;
00000113                      569  	;***      261 : 				} else {
00000113                      570  	;***      262 : 					sio_dummy = SIO01;
00000113                      571  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 262
00000113 8D12                 572  	mov a, 0xFFF12
00000115 9801                 573  	mov [sp+0x01], a
00000117 EF00                 574  	br $.BB@LABEL@9_7
00000119                      575  .BB@LABEL@9_6:	; if_then_bb52
00000119 14                   576  	movw de, ax
0000011A                      577  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 260
0000011A 8D12                 578  	mov a, 0xFFF12
0000011C 99                   579  	mov [de], a
0000011D                      580  .BB@LABEL@9_7:	; if_break_bb59
0000011D                      581  	;***      263 : 				}
0000011D                      582  	;***      264 : 			}
0000011D                      583  	;***      265 : 
0000011D                      584  	;***      266 : 			r_csi01_callback_sendend(); /* complete send */
0000011D                      585  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 266
0000011D FC000000             586  	call !!_r_csi01_callback_sendend@1
00000121                      587  	;***      267 : 			r_csi01_callback_receiveend(); /* complete receive */
00000121                      588  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 267
00000121 FC000000             589  	call !!_r_csi01_callback_receiveend@1
00000125 EF00                 590  	br $.BB@LABEL@9_15
00000127                      591  .BB@LABEL@9_8:	; if_then_bb16
00000127                      592  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 242
00000127 AF0000               593  	movw ax, !LOWW(_gp_csi01_rx_address)
0000012A 43                   594  	cmpw ax, bc
0000012B DF00                 595  	bnz $.BB@LABEL@9_10
0000012D                      596  .BB@LABEL@9_9:	; if_else_bb26
0000012D                      597  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 246
0000012D 8D12                 598  	mov a, 0xFFF12
0000012F 9801                 599  	mov [sp+0x01], a
00000131 EF00                 600  	br $.BB@LABEL@9_11
00000133                      601  .BB@LABEL@9_10:	; if_then_bb21
00000133 14                   602  	movw de, ax
00000134                      603  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 243
00000134 8D12                 604  	mov a, 0xFFF12
00000136 99                   605  	mov [de], a
00000137                      606  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 244
00000137 A20000               607  	incw !LOWW(_gp_csi01_rx_address)
0000013A                      608  .BB@LABEL@9_11:	; if_break_bb
0000013A                      609  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 249
0000013A AF0000               610  	movw ax, !LOWW(_gp_csi01_tx_address)
0000013D 43                   611  	cmpw ax, bc
0000013E DF00                 612  	bnz $.BB@LABEL@9_13
00000140                      613  .BB@LABEL@9_12:	; if_else_bb38
00000140                      614  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 253
00000140 CD12FF               615  	mov 0xFFF12, #0xFF
00000143 EF00                 616  	br $.BB@LABEL@9_14
00000145                      617  .BB@LABEL@9_13:	; if_then_bb32
00000145 14                   618  	movw de, ax
00000146                      619  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 250
00000146 89                   620  	mov a, [de]
00000147 9D12                 621  	mov 0xFFF12, a
00000149                      622  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 251
00000149 A5                   623  	incw de
0000014A 15                   624  	movw ax, de
0000014B BF0000               625  	movw !LOWW(_gp_csi01_tx_address), ax
0000014E                      626  .BB@LABEL@9_14:	; if_break_bb39
0000014E                      627  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 256
0000014E B20000               628  	decw !LOWW(_g_csi01_tx_count)
00000151                      629  .BB@LABEL@9_15:	; if_break_bb39
00000151 C6                   630  	pop hl
00000152 C0                   631  	pop ax
00000153 9EFC                 632  	mov cs, a
00000155 60                   633  	mov a, x
00000156 9EFD                 634  	mov es, a
00000158 C6                   635  	pop hl
00000159 C4                   636  	pop de
0000015A C2                   637  	pop bc
0000015B C0                   638  	pop ax
0000015C                      639  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 270
0000015C 61FC                 640  	reti
00000005                      641  	.SECTION .textf,TEXTF
00000005                      642  _r_csi01_callback_receiveend@1:
00000005                      643  	.STACK _r_csi01_callback_receiveend@1 = 4
00000005                      644  	;***      268 : 		}
00000005                      645  	;***      269 : 	}
00000005                      646  	;***      270 : }
00000005                      647  	;***      271 : 
00000005                      648  	;***      272 : /***********************************************************************************************************************
00000005                      649  	;***      273 :  * Function Name: r_csi01_callback_receiveend
00000005                      650  	;***      274 :  * Description  : This function is a callback function when CSI01 finishes reception.
00000005                      651  	;***      275 :  * Arguments    : None
00000005                      652  	;***      276 :  * Return Value : None
00000005                      653  	;***      277 :  ***********************************************************************************************************************/
00000005                      654  	;***      278 : static void r_csi01_callback_receiveend(void) {
00000005                      655  	;***      279 : 	/* Start user code. Do not edit comment generated here */
00000005                      656  	;***      280 : 	g_csi_rev_end++;
00000005                      657  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 280
00000005 A00000               658  	inc !LOWW(_g_csi_rev_end)
00000008                      659  	;***      281 : 	R_CSI01_Stop();
00000008                      660  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 281
00000008 EC000000             661  	br !!_R_CSI01_Stop
0000000C                      662  _r_csi01_callback_error@1:
0000000C                      663  	.STACK _r_csi01_callback_error@1 = 4
0000000C                      664  	;***      282 : 	/* End user code. Do not edit comment generated here */
0000000C                      665  	;***      283 : }
0000000C                      666  	;***      284 : 
0000000C                      667  	;***      285 : /***********************************************************************************************************************
0000000C                      668  	;***      286 :  * Function Name: r_csi01_callback_error
0000000C                      669  	;***      287 :  * Description  : This function is a callback function when CSI01 reception error occurs.
0000000C                      670  	;***      288 :  * Arguments    : err_type -
0000000C                      671  	;***      289 :  *                    error type value
0000000C                      672  	;***      290 :  * Return Value : None
0000000C                      673  	;***      291 :  ***********************************************************************************************************************/
0000000C                      674  	;***      292 : static void r_csi01_callback_error(uint8_t err_type) {
0000000C                      675  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 292
0000000C D7                   676  	ret
0000000D                      677  _r_csi01_callback_sendend@1:
0000000D                      678  	.STACK _r_csi01_callback_sendend@1 = 4
0000000D                      679  	;***      293 : 	/* Start user code. Do not edit comment generated here */
0000000D                      680  	;***      294 : 
0000000D                      681  	;***      295 : 	/* End user code. Do not edit comment generated here */
0000000D                      682  	;***      296 : }
0000000D                      683  	;***      297 : 
0000000D                      684  	;***      298 : /***********************************************************************************************************************
0000000D                      685  	;***      299 :  * Function Name: r_csi01_callback_sendend
0000000D                      686  	;***      300 :  * Description  : This function is a callback function when CSI01 finishes transmission.
0000000D                      687  	;***      301 :  * Arguments    : None
0000000D                      688  	;***      302 :  * Return Value : None
0000000D                      689  	;***      303 :  ***********************************************************************************************************************/
0000000D                      690  	;***      304 : static void r_csi01_callback_sendend(void) {
0000000D                      691  	;***      305 : 	/* Start user code. Do not edit comment generated here */
0000000D                      692  	;***      306 : 	g_csi_send_end++;
0000000D                      693  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 306
0000000D A00000               694  	inc !LOWW(_g_csi_send_end)
00000010 D7                   695  	ret
0000015E                      696  	.SECTION .text,TEXT
0000015E                      697  _r_uart2_interrupt_receive@1	.vector 0x0016
0000015E                      698  _r_uart2_interrupt_receive@1:
0000015E                      699  	.STACK _r_uart2_interrupt_receive@1 = 16
0000015E                      700  	;***      307 : 	/* End user code. Do not edit comment generated here */
0000015E                      701  	;***      308 : }
0000015E                      702  	;***      309 : 
0000015E                      703  	;***      310 : /***********************************************************************************************************************
0000015E                      704  	;***      311 :  * Function Name: r_uart2_interrupt_receive
0000015E                      705  	;***      312 :  * Description  : This function is INTSR2 interrupt service routine.
0000015E                      706  	;***      313 :  * Arguments    : None
0000015E                      707  	;***      314 :  * Return Value : None
0000015E                      708  	;***      315 :  ***********************************************************************************************************************/
0000015E                      709  	;***      316 : static void __near r_uart2_interrupt_receive(void) {
0000015E                      710  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 316
0000015E C1                   711  	push ax
0000015F C3                   712  	push bc
00000160 C5                   713  	push de
00000161 C7                   714  	push hl
00000162 8EFD                 715  	mov a, es
00000164 70                   716  	mov x, a
00000165 8EFC                 717  	mov a, cs
00000167 C1                   718  	push ax
00000168 C7                   719  	push hl
00000169                      720  	;***      317 : 	volatile uint8_t rx_data;
00000169                      721  	;***      318 : 	volatile uint8_t err_type;
00000169                      722  	;***      319 : 
00000169                      723  	;***      320 : 	err_type = (uint8_t) (SSR11 & 0x0007U);
00000169                      724  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 320
00000169 AF4201               725  	movw ax, !0x0142
0000016C 60                   726  	mov a, x
0000016D 5C07                 727  	and a, #0x07
0000016F 9800                 728  	mov [sp+0x00], a
00000171                      729  	;***      321 : 	SIR11 = (uint16_t) err_type;
00000171                      730  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 321
00000171 8800                 731  	mov a, [sp+0x00]
00000173 318E                 732  	shrw ax, 8+0x00000
00000175 BF4A01               733  	movw !0x014A, ax
00000178                      734  	;***      322 : 
00000178                      735  	;***      323 : 	if (err_type != 0U) {
00000178                      736  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 323
00000178 8800                 737  	mov a, [sp+0x00]
0000017A D1                   738  	cmp0 a
0000017B DD00                 739  	bz $.BB@LABEL@13_2
0000017D                      740  .BB@LABEL@13_1:	; if_then_bb
0000017D                      741  	;***      324 : 		r_uart2_callback_error(err_type);
0000017D                      742  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 324
0000017D 8800                 743  	mov a, [sp+0x00]
0000017F FC000000             744  	call !!_r_uart2_callback_error@1
00000183                      745  .BB@LABEL@13_2:	; if_break_bb
00000183                      746  	;***      325 : 	}
00000183                      747  	;***      326 : 
00000183                      748  	;***      327 : 	rx_data = RXD2;
00000183                      749  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 327
00000183 8E4A                 750  	mov a, 0xFFF4A
00000185 9801                 751  	mov [sp+0x01], a
00000187                      752  	;***      328 : 
00000187                      753  	;***      329 : 	if (g_uart2_rx_length > g_uart2_rx_count) {
00000187                      754  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 329
00000187 AF0000               755  	movw ax, !LOWW(_g_uart2_rx_length)
0000018A 420000               756  	cmpw ax, !LOWW(_g_uart2_rx_count)
0000018D 8801                 757  	mov a, [sp+0x01]
0000018F 61D300               758  	bnh $.BB@LABEL@13_6
00000192                      759  .BB@LABEL@13_3:	; if_then_bb18
00000192                      760  	;***      330 : 		*gp_uart2_rx_address = rx_data;
00000192                      761  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 330
00000192 EB0000               762  	movw de, !LOWW(_gp_uart2_rx_address)
00000195 99                   763  	mov [de], a
00000196                      764  	;***      331 : 		gp_uart2_rx_address++;
00000196                      765  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 331
00000196 A20000               766  	incw !LOWW(_gp_uart2_rx_address)
00000199                      767  	;***      332 : 		g_uart2_rx_count++;
00000199                      768  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 332
00000199 A20000               769  	incw !LOWW(_g_uart2_rx_count)
0000019C                      770  	;***      333 : 
0000019C                      771  	;***      334 : 		if (g_uart2_rx_length == g_uart2_rx_count) {
0000019C                      772  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 334
0000019C AF0000               773  	movw ax, !LOWW(_g_uart2_rx_length)
0000019F 420000               774  	cmpw ax, !LOWW(_g_uart2_rx_count)
000001A2 61F8                 775  	sknz
000001A4                      776  .BB@LABEL@13_4:	; if_then_bb30
000001A4                      777  	;***      335 : 			r_uart2_callback_receiveend();
000001A4                      778  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 335
000001A4 FC000000             779  	call !!_r_uart2_callback_receiveend@1
000001A8                      780  .BB@LABEL@13_5:	; return
000001A8 C6                   781  	pop hl
000001A9 C0                   782  	pop ax
000001AA 9EFC                 783  	mov cs, a
000001AC 60                   784  	mov a, x
000001AD 9EFD                 785  	mov es, a
000001AF C6                   786  	pop hl
000001B0 C4                   787  	pop de
000001B1 C2                   788  	pop bc
000001B2 C0                   789  	pop ax
000001B3                      790  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 340
000001B3 61FC                 791  	reti
000001B5                      792  .BB@LABEL@13_6:	; if_else_bb
000001B5                      793  	;***      336 : 		}
000001B5                      794  	;***      337 : 	} else {
000001B5                      795  	;***      338 : 		r_uart2_callback_softwareoverrun(rx_data);
000001B5                      796  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 338
000001B5 318E                 797  	shrw ax, 8+0x00000
000001B7 FC000000             798  	call !!_r_uart2_callback_softwareoverrun@1
000001BB EF00                 799  	br $.BB@LABEL@13_5
000001BD                      800  _r_uart2_interrupt_send@1	.vector 0x0014
000001BD                      801  _r_uart2_interrupt_send@1:
000001BD                      802  	.STACK _r_uart2_interrupt_send@1 = 14
000001BD                      803  	;***      339 : 	}
000001BD                      804  	;***      340 : }
000001BD                      805  	;***      341 : 
000001BD                      806  	;***      342 : /***********************************************************************************************************************
000001BD                      807  	;***      343 :  * Function Name: r_uart2_interrupt_send
000001BD                      808  	;***      344 :  * Description  : This function is INTST2 interrupt service routine.
000001BD                      809  	;***      345 :  * Arguments    : None
000001BD                      810  	;***      346 :  * Return Value : None
000001BD                      811  	;***      347 :  ***********************************************************************************************************************/
000001BD                      812  	;***      348 : static void __near r_uart2_interrupt_send(void) {
000001BD                      813  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 348
000001BD C1                   814  	push ax
000001BE C3                   815  	push bc
000001BF C5                   816  	push de
000001C0 C7                   817  	push hl
000001C1 8EFD                 818  	mov a, es
000001C3 70                   819  	mov x, a
000001C4 8EFC                 820  	mov a, cs
000001C6 C1                   821  	push ax
000001C7                      822  	;***      349 : 	if (g_uart2_tx_count > 0U) {
000001C7                      823  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 349
000001C7 AF0000               824  	movw ax, !LOWW(_g_uart2_tx_count)
000001CA F7                   825  	clrw bc
000001CB 43                   826  	cmpw ax, bc
000001CC DF00                 827  	bnz $.BB@LABEL@14_3
000001CE                      828  .BB@LABEL@14_1:	; if_else_bb
000001CE                      829  	;***      350 : 		TXD2 = *gp_uart2_tx_address;
000001CE                      830  	;***      351 : 		gp_uart2_tx_address++;
000001CE                      831  	;***      352 : 		g_uart2_tx_count--;
000001CE                      832  	;***      353 : 	} else {
000001CE                      833  	;***      354 : 		r_uart2_callback_sendend();
000001CE                      834  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 354
000001CE FC000000             835  	call !!_r_uart2_callback_sendend@1
000001D2                      836  .BB@LABEL@14_2:	; if_else_bb
000001D2 C0                   837  	pop ax
000001D3 9EFC                 838  	mov cs, a
000001D5 60                   839  	mov a, x
000001D6 9EFD                 840  	mov es, a
000001D8 C6                   841  	pop hl
000001D9 C4                   842  	pop de
000001DA C2                   843  	pop bc
000001DB C0                   844  	pop ax
000001DC                      845  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 356
000001DC 61FC                 846  	reti
000001DE                      847  .BB@LABEL@14_3:	; if_then_bb
000001DE                      848  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 350
000001DE EB0000               849  	movw de, !LOWW(_gp_uart2_tx_address)
000001E1 89                   850  	mov a, [de]
000001E2 9E48                 851  	mov 0xFFF48, a
000001E4                      852  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 351
000001E4 A5                   853  	incw de
000001E5 15                   854  	movw ax, de
000001E6 BF0000               855  	movw !LOWW(_gp_uart2_tx_address), ax
000001E9                      856  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 352
000001E9 B20000               857  	decw !LOWW(_g_uart2_tx_count)
000001EC EF00                 858  	br $.BB@LABEL@14_2
00000011                      859  	.SECTION .textf,TEXTF
00000011                      860  _r_uart2_callback_receiveend@1:
00000011                      861  	.STACK _r_uart2_callback_receiveend@1 = 4
00000011                      862  	;***      355 : 	}
00000011                      863  	;***      356 : }
00000011                      864  	;***      357 : 
00000011                      865  	;***      358 : /***********************************************************************************************************************
00000011                      866  	;***      359 :  * Function Name: r_uart2_callback_receiveend
00000011                      867  	;***      360 :  * Description  : This function is a callback function when UART2 finishes reception.
00000011                      868  	;***      361 :  * Arguments    : None
00000011                      869  	;***      362 :  * Return Value : None
00000011                      870  	;***      363 :  ***********************************************************************************************************************/
00000011                      871  	;***      364 : static void r_uart2_callback_receiveend(void) {
00000011                      872  	;***      365 : 	/* Start user code. Do not edit comment generated here */
00000011                      873  	;***      366 : 	uart2_handle();
00000011                      874  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 366
00000011 EC000000             875  	br !!_uart2_handle
00000015                      876  _r_uart2_callback_softwareoverrun@1:
00000015                      877  	.STACK _r_uart2_callback_softwareoverrun@1 = 4
00000015                      878  	;***      367 : 	/* End user code. Do not edit comment generated here */
00000015                      879  	;***      368 : }
00000015                      880  	;***      369 : 
00000015                      881  	;***      370 : /***********************************************************************************************************************
00000015                      882  	;***      371 :  * Function Name: r_uart2_callback_softwareoverrun
00000015                      883  	;***      372 :  * Description  : This function is a callback function when UART2 receives an overflow data.
00000015                      884  	;***      373 :  * Arguments    : rx_data -
00000015                      885  	;***      374 :  *                    receive data
00000015                      886  	;***      375 :  * Return Value : None
00000015                      887  	;***      376 :  ***********************************************************************************************************************/
00000015                      888  	;***      377 : static void r_uart2_callback_softwareoverrun(uint16_t rx_data) {
00000015                      889  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 377
00000015 D7                   890  	ret
00000016                      891  _r_uart2_callback_sendend@1:
00000016                      892  	.STACK _r_uart2_callback_sendend@1 = 4
00000016                      893  	;***      378 : 	/* Start user code. Do not edit comment generated here */
00000016                      894  	;***      379 : 	/* End user code. Do not edit comment generated here */
00000016                      895  	;***      380 : }
00000016                      896  	;***      381 : 
00000016                      897  	;***      382 : /***********************************************************************************************************************
00000016                      898  	;***      383 :  * Function Name: r_uart2_callback_sendend
00000016                      899  	;***      384 :  * Description  : This function is a callback function when UART2 finishes transmission.
00000016                      900  	;***      385 :  * Arguments    : None
00000016                      901  	;***      386 :  * Return Value : None
00000016                      902  	;***      387 :  ***********************************************************************************************************************/
00000016                      903  	;***      388 : static void r_uart2_callback_sendend(void) {
00000016                      904  	;***      389 : 	/* Start user code. Do not edit comment generated here */
00000016                      905  	;***      390 : 	g_uart2_sendend++;
00000016                      906  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 390
00000016 A00000               907  	inc !LOWW(_g_uart2_sendend)
00000019 D7                   908  	ret
0000001A                      909  _r_uart2_callback_error@1:
0000001A                      910  	.STACK _r_uart2_callback_error@1 = 4
0000001A                      911  	;***      391 : 	/* End user code. Do not edit comment generated here */
0000001A                      912  	;***      392 : }
0000001A                      913  	;***      393 : 
0000001A                      914  	;***      394 : /***********************************************************************************************************************
0000001A                      915  	;***      395 :  * Function Name: r_uart2_callback_error
0000001A                      916  	;***      396 :  * Description  : This function is a callback function when UART2 reception error occurs.
0000001A                      917  	;***      397 :  * Arguments    : err_type -
0000001A                      918  	;***      398 :  *                    error type value
0000001A                      919  	;***      399 :  * Return Value : None
0000001A                      920  	;***      400 :  ***********************************************************************************************************************/
0000001A                      921  	;***      401 : static void r_uart2_callback_error(uint8_t err_type) {
0000001A                      922  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 401
0000001A D7                   923  	ret
000001EE                      924  	.SECTION .text,TEXT
000001EE                      925  _r_uart3_interrupt_receive@1	.vector 0x003E
000001EE                      926  _r_uart3_interrupt_receive@1:
000001EE                      927  	.STACK _r_uart3_interrupt_receive@1 = 16
000001EE                      928  	;***      402 : 	/* Start user code. Do not edit comment generated here */
000001EE                      929  	;***      403 : 	/* End user code. Do not edit comment generated here */
000001EE                      930  	;***      404 : }
000001EE                      931  	;***      405 : 
000001EE                      932  	;***      406 : /***********************************************************************************************************************
000001EE                      933  	;***      407 :  * Function Name: r_uart3_interrupt_receive
000001EE                      934  	;***      408 :  * Description  : This function is INTSR3 interrupt service routine.
000001EE                      935  	;***      409 :  * Arguments    : None
000001EE                      936  	;***      410 :  * Return Value : None
000001EE                      937  	;***      411 :  ***********************************************************************************************************************/
000001EE                      938  	;***      412 : static void __near r_uart3_interrupt_receive(void) {
000001EE                      939  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 412
000001EE C1                   940  	push ax
000001EF C3                   941  	push bc
000001F0 C5                   942  	push de
000001F1 C7                   943  	push hl
000001F2 8EFD                 944  	mov a, es
000001F4 70                   945  	mov x, a
000001F5 8EFC                 946  	mov a, cs
000001F7 C1                   947  	push ax
000001F8 C7                   948  	push hl
000001F9                      949  	;***      413 : 	volatile uint8_t rx_data;
000001F9                      950  	;***      414 : 	volatile uint8_t err_type;
000001F9                      951  	;***      415 : 
000001F9                      952  	;***      416 : 	err_type = (uint8_t) (SSR13 & 0x0007U);
000001F9                      953  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 416
000001F9 AF4601               954  	movw ax, !0x0146
000001FC 60                   955  	mov a, x
000001FD 5C07                 956  	and a, #0x07
000001FF 9800                 957  	mov [sp+0x00], a
00000201                      958  	;***      417 : 	SIR13 = (uint16_t) err_type;
00000201                      959  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 417
00000201 8800                 960  	mov a, [sp+0x00]
00000203 318E                 961  	shrw ax, 8+0x00000
00000205 BF4E01               962  	movw !0x014E, ax
00000208                      963  	;***      418 : 
00000208                      964  	;***      419 : 	if (err_type != 0U) {
00000208                      965  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 419
00000208 8800                 966  	mov a, [sp+0x00]
0000020A D1                   967  	cmp0 a
0000020B DD00                 968  	bz $.BB@LABEL@19_2
0000020D                      969  .BB@LABEL@19_1:	; if_then_bb
0000020D                      970  	;***      420 : 		r_uart3_callback_error(err_type);
0000020D                      971  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 420
0000020D 8800                 972  	mov a, [sp+0x00]
0000020F FC000000             973  	call !!_r_uart3_callback_error@1
00000213                      974  .BB@LABEL@19_2:	; if_break_bb
00000213                      975  	;***      421 : 	}
00000213                      976  	;***      422 : 
00000213                      977  	;***      423 : 	rx_data = RXD3;
00000213                      978  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 423
00000213 8D16                 979  	mov a, 0xFFF16
00000215 9801                 980  	mov [sp+0x01], a
00000217                      981  	;***      424 : 
00000217                      982  	;***      425 : 	if (g_uart3_rx_length > g_uart3_rx_count) {
00000217                      983  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 425
00000217 AF0000               984  	movw ax, !LOWW(_g_uart3_rx_length)
0000021A 420000               985  	cmpw ax, !LOWW(_g_uart3_rx_count)
0000021D 8801                 986  	mov a, [sp+0x01]
0000021F 61D300               987  	bnh $.BB@LABEL@19_6
00000222                      988  .BB@LABEL@19_3:	; if_then_bb18
00000222                      989  	;***      426 : 		*gp_uart3_rx_address = rx_data;
00000222                      990  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 426
00000222 EB0000               991  	movw de, !LOWW(_gp_uart3_rx_address)
00000225 99                   992  	mov [de], a
00000226                      993  	;***      427 : 		gp_uart3_rx_address++;
00000226                      994  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 427
00000226 A20000               995  	incw !LOWW(_gp_uart3_rx_address)
00000229                      996  	;***      428 : 		g_uart3_rx_count++;
00000229                      997  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 428
00000229 A20000               998  	incw !LOWW(_g_uart3_rx_count)
0000022C                      999  	;***      429 : 
0000022C                     1000  	;***      430 : 		if (g_uart3_rx_length == g_uart3_rx_count) {
0000022C                     1001  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 430
0000022C AF0000              1002  	movw ax, !LOWW(_g_uart3_rx_length)
0000022F 420000              1003  	cmpw ax, !LOWW(_g_uart3_rx_count)
00000232 61F8                1004  	sknz
00000234                     1005  .BB@LABEL@19_4:	; if_then_bb30
00000234                     1006  	;***      431 : 			r_uart3_callback_receiveend();
00000234                     1007  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 431
00000234 FC000000            1008  	call !!_r_uart3_callback_receiveend@1
00000238                     1009  .BB@LABEL@19_5:	; return
00000238 C6                  1010  	pop hl
00000239 C0                  1011  	pop ax
0000023A 9EFC                1012  	mov cs, a
0000023C 60                  1013  	mov a, x
0000023D 9EFD                1014  	mov es, a
0000023F C6                  1015  	pop hl
00000240 C4                  1016  	pop de
00000241 C2                  1017  	pop bc
00000242 C0                  1018  	pop ax
00000243                     1019  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 436
00000243 61FC                1020  	reti
00000245                     1021  .BB@LABEL@19_6:	; if_else_bb
00000245                     1022  	;***      432 : 		}
00000245                     1023  	;***      433 : 	} else {
00000245                     1024  	;***      434 : 		r_uart3_callback_softwareoverrun(rx_data);
00000245                     1025  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 434
00000245 318E                1026  	shrw ax, 8+0x00000
00000247 FC000000            1027  	call !!_r_uart3_callback_softwareoverrun@1
0000024B EF00                1028  	br $.BB@LABEL@19_5
0000024D                     1029  _r_uart3_interrupt_send@1	.vector 0x003C
0000024D                     1030  _r_uart3_interrupt_send@1:
0000024D                     1031  	.STACK _r_uart3_interrupt_send@1 = 14
0000024D                     1032  	;***      435 : 	}
0000024D                     1033  	;***      436 : }
0000024D                     1034  	;***      437 : 
0000024D                     1035  	;***      438 : /***********************************************************************************************************************
0000024D                     1036  	;***      439 :  * Function Name: r_uart3_interrupt_send
0000024D                     1037  	;***      440 :  * Description  : This function is INTST3 interrupt service routine.
0000024D                     1038  	;***      441 :  * Arguments    : None
0000024D                     1039  	;***      442 :  * Return Value : None
0000024D                     1040  	;***      443 :  ***********************************************************************************************************************/
0000024D                     1041  	;***      444 : static void __near r_uart3_interrupt_send(void) {
0000024D                     1042  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 444
0000024D C1                  1043  	push ax
0000024E C3                  1044  	push bc
0000024F C5                  1045  	push de
00000250 C7                  1046  	push hl
00000251 8EFD                1047  	mov a, es
00000253 70                  1048  	mov x, a
00000254 8EFC                1049  	mov a, cs
00000256 C1                  1050  	push ax
00000257                     1051  	;***      445 : 	if (g_uart3_tx_count > 0U) {
00000257                     1052  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 445
00000257 AF0000              1053  	movw ax, !LOWW(_g_uart3_tx_count)
0000025A F7                  1054  	clrw bc
0000025B 43                  1055  	cmpw ax, bc
0000025C DF00                1056  	bnz $.BB@LABEL@20_3
0000025E                     1057  .BB@LABEL@20_1:	; if_else_bb
0000025E                     1058  	;***      446 : 		TXD3 = *gp_uart3_tx_address;
0000025E                     1059  	;***      447 : 		gp_uart3_tx_address++;
0000025E                     1060  	;***      448 : 		g_uart3_tx_count--;
0000025E                     1061  	;***      449 : 	} else {
0000025E                     1062  	;***      450 : 		r_uart3_callback_sendend();
0000025E                     1063  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 450
0000025E FC000000            1064  	call !!_r_uart3_callback_sendend@1
00000262                     1065  .BB@LABEL@20_2:	; if_else_bb
00000262 C0                  1066  	pop ax
00000263 9EFC                1067  	mov cs, a
00000265 60                  1068  	mov a, x
00000266 9EFD                1069  	mov es, a
00000268 C6                  1070  	pop hl
00000269 C4                  1071  	pop de
0000026A C2                  1072  	pop bc
0000026B C0                  1073  	pop ax
0000026C                     1074  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 452
0000026C 61FC                1075  	reti
0000026E                     1076  .BB@LABEL@20_3:	; if_then_bb
0000026E                     1077  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 446
0000026E EB0000              1078  	movw de, !LOWW(_gp_uart3_tx_address)
00000271 89                  1079  	mov a, [de]
00000272 9D14                1080  	mov 0xFFF14, a
00000274                     1081  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 447
00000274 A5                  1082  	incw de
00000275 15                  1083  	movw ax, de
00000276 BF0000              1084  	movw !LOWW(_gp_uart3_tx_address), ax
00000279                     1085  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 448
00000279 B20000              1086  	decw !LOWW(_g_uart3_tx_count)
0000027C EF00                1087  	br $.BB@LABEL@20_2
0000001B                     1088  	.SECTION .textf,TEXTF
0000001B                     1089  _r_uart3_callback_receiveend@1:
0000001B                     1090  	.STACK _r_uart3_callback_receiveend@1 = 4
0000001B                     1091  	;***      451 : 	}
0000001B                     1092  	;***      452 : }
0000001B                     1093  	;***      453 : 
0000001B                     1094  	;***      454 : /***********************************************************************************************************************
0000001B                     1095  	;***      455 :  * Function Name: r_uart3_callback_receiveend
0000001B                     1096  	;***      456 :  * Description  : This function is a callback function when UART3 finishes reception.
0000001B                     1097  	;***      457 :  * Arguments    : None
0000001B                     1098  	;***      458 :  * Return Value : None
0000001B                     1099  	;***      459 :  ***********************************************************************************************************************/
0000001B                     1100  	;***      460 : static void r_uart3_callback_receiveend(void) {
0000001B                     1101  	;***      461 : 	/* Start user code. Do not edit comment generated here */
0000001B                     1102  	;***      462 : 	R_UART3_Receive(g_uart3_rx_data, 7);
0000001B                     1103  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 462
0000001B 320700              1104  	movw bc, #0x0007
0000001E 300000              1105  	movw ax, #LOWW(_g_uart3_rx_data)
00000021 FC000000            1106  	call !!_R_UART3_Receive
00000025                     1107  	;***      463 : 	if (g_uart3_rx_data[0] == 1) {
00000025                     1108  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 463
00000025 8F0000              1109  	mov a, !LOWW(_g_uart3_rx_data)
00000028 4C01                1110  	cmp a, #0x01
0000002A DF00                1111  	bnz $.BB@LABEL@21_7
0000002C                     1112  .BB@LABEL@21_1:	; if_then_bb
0000002C                     1113  	;***      464 : 		//Read timer setting
0000002C                     1114  	;***      465 : 		if ((rs485_rx_p[0] == H_READ) && (rs485_rx_p[1] == READ_TIME)) {
0000002C                     1115  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 465
0000002C 40000052            1116  	cmp !LOWW(_g_uart3_rx_data+0x00001), #0x52
00000030 DF00                1117  	bnz $.BB@LABEL@21_6
00000032                     1118  .BB@LABEL@21_2:	; bb
00000032 40000002            1119  	cmp !LOWW(_g_uart3_rx_data+0x00002), #0x02
00000036 DF00                1120  	bnz $.BB@LABEL@21_4
00000038                     1121  .BB@LABEL@21_3:	; if_then_bb25
00000038                     1122  	;***      466 : 			g_commnunication_flag.rs485_send_to_watersolfner_response_flag = 1;
00000038                     1123  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 466
00000038 E50000              1124  	oneb !LOWW(_g_commnunication_flag+0x0000A)
0000003B D7                  1125  	ret
0000003C                     1126  .BB@LABEL@21_4:	; bb32
0000003C                     1127  	;***      467 : 		} else if ((rs485_rx_p[0] == 82) && (rs485_rx_p[1] == 24)) {
0000003C                     1128  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 467
0000003C 40000018            1129  	cmp !LOWW(_g_uart3_rx_data+0x00002), #0x18
00000040 61F8                1130  	sknz
00000042                     1131  .BB@LABEL@21_5:	; if_then_bb47
00000042                     1132  	;***      468 : 			g_commnunication_flag.rs485_send_to_watersolfner_SV1_flag = 1;
00000042                     1133  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 468
00000042 E50000              1134  	oneb !LOWW(_g_commnunication_flag+0x0000B)
00000045                     1135  .BB@LABEL@21_6:	; if_else_bb.if_else_bb48_crit_edge.critedge
00000045                     1136  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 485
00000045 D7                  1137  	ret
00000046                     1138  .BB@LABEL@21_7:	; if_else_bb97
00000046                     1139  	;***      469 : 		} else if ((rs485_rx_p[0] == 83) && (rs485_rx_p[1] == 70)) {
00000046                     1140  	;***      470 : 			//TODO: Start Water Softener
00000046                     1141  	;***      471 : 
00000046                     1142  	;***      472 : 		} else if ((rs485_rx_p[0] == 83) && (rs485_rx_p[1] == 80)) {
00000046                     1143  	;***      473 : 			//TODO: Stop Water Softener + Time of SNP ON (4 bytes)
00000046                     1144  	;***      474 : 		}
00000046                     1145  	;***      475 : 	} else if (g_uart3_rx_data[0] == 2) {
00000046                     1146  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 475
00000046 4C02                1147  	cmp a, #0x02
00000048 DF00                1148  	bnz $.BB@LABEL@21_12
0000004A                     1149  .BB@LABEL@21_8:	; if_then_bb103
0000004A                     1150  	;***      476 : 		if ((rs485_rx_p[0] == 11)) {
0000004A                     1151  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 476
0000004A 8F0000              1152  	mov a, !LOWW(_g_uart3_rx_data+0x00001)
0000004D 4C0B                1153  	cmp a, #0x0B
0000004F DF00                1154  	bnz $.BB@LABEL@21_10
00000051                     1155  .BB@LABEL@21_9:	; if_then_bb111
00000051                     1156  	;***      477 : 			g_commnunication_flag.rs485_send_to_valve_response_flag = 1;
00000051                     1157  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 477
00000051 E50000              1158  	oneb !LOWW(_g_commnunication_flag+0x0000C)
00000054 D7                  1159  	ret
00000055                     1160  .BB@LABEL@21_10:	; if_else_bb112
00000055                     1161  	;***      478 : 		} else if ((rs485_rx_p[0] == 12)) {
00000055                     1162  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 478
00000055 4C0C                1163  	cmp a, #0x0C
00000057 DF00                1164  	bnz $.BB@LABEL@21_14
00000059                     1165  .BB@LABEL@21_11:	; if_then_bb120
00000059                     1166  	;***      479 : 			g_commnunication_flag.rs485_get_valve_gesture_flag = 1;
00000059                     1167  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 479
00000059 E50000              1168  	oneb !LOWW(_g_commnunication_flag+0x0000D)
0000005C D7                  1169  	ret
0000005D                     1170  .BB@LABEL@21_12:	; if_else_bb123
0000005D                     1171  	;***      480 : 		}
0000005D                     1172  	;***      481 : 	} else if (g_uart3_rx_data[0] != 0xff) {
0000005D                     1173  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 481
0000005D 81                  1174  	inc a
0000005E 61E8                1175  	skz
00000060                     1176  .BB@LABEL@21_13:	; if_then_bb129
00000060                     1177  	;***      482 : 		g_commnunication_flag.rs485_fault = 1;
00000060                     1178  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 482
00000060 E50000              1179  	oneb !LOWW(_g_commnunication_flag+0x0000E)
00000063                     1180  .BB@LABEL@21_14:	; return
00000063                     1181  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 485
00000063 D7                  1182  	ret
00000064                     1183  _r_uart3_callback_softwareoverrun@1:
00000064                     1184  	.STACK _r_uart3_callback_softwareoverrun@1 = 4
00000064                     1185  	;***      483 : 	}
00000064                     1186  	;***      484 : 	/* End user code. Do not edit comment generated here */
00000064                     1187  	;***      485 : }
00000064                     1188  	;***      486 : 
00000064                     1189  	;***      487 : /***********************************************************************************************************************
00000064                     1190  	;***      488 :  * Function Name: r_uart3_callback_softwareoverrun
00000064                     1191  	;***      489 :  * Description  : This function is a callback function when UART3 receives an overflow data.
00000064                     1192  	;***      490 :  * Arguments    : rx_data -
00000064                     1193  	;***      491 :  *                    receive data
00000064                     1194  	;***      492 :  * Return Value : None
00000064                     1195  	;***      493 :  ***********************************************************************************************************************/
00000064                     1196  	;***      494 : static void r_uart3_callback_softwareoverrun(uint16_t rx_data) {
00000064                     1197  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 494
00000064 D7                  1198  	ret
00000065                     1199  _r_uart3_callback_sendend@1:
00000065                     1200  	.STACK _r_uart3_callback_sendend@1 = 4
00000065                     1201  	;***      495 : 	/* Start user code. Do not edit comment generated here */
00000065                     1202  	;***      496 : 	/* End user code. Do not edit comment generated here */
00000065                     1203  	;***      497 : }
00000065                     1204  	;***      498 : 
00000065                     1205  	;***      499 : /***********************************************************************************************************************
00000065                     1206  	;***      500 :  * Function Name: r_uart3_callback_sendend
00000065                     1207  	;***      501 :  * Description  : This function is a callback function when UART3 finishes transmission.
00000065                     1208  	;***      502 :  * Arguments    : None
00000065                     1209  	;***      503 :  * Return Value : None
00000065                     1210  	;***      504 :  ***********************************************************************************************************************/
00000065                     1211  	;***      505 : static void r_uart3_callback_sendend(void) {
00000065                     1212  	;***      506 : 	/* Start user code. Do not edit comment generated here */
00000065                     1213  	;***      507 : 	g_uart3_sendend++;
00000065                     1214  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 507
00000065 A00000              1215  	inc !LOWW(_g_uart3_sendend)
00000068                     1216  	;***      508 : 	O_RS485_MODE_PIN = 0U;
00000068                     1217  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 508
00000068 710300              1218  	clr1 0xFFF00.0
0000006B D7                  1219  	ret
0000006C                     1220  _r_uart3_callback_error@1:
0000006C                     1221  	.STACK _r_uart3_callback_error@1 = 4
0000006C                     1222  	;***      509 : 	/* End user code. Do not edit comment generated here */
0000006C                     1223  	;***      510 : }
0000006C                     1224  	;***      511 : 
0000006C                     1225  	;***      512 : /***********************************************************************************************************************
0000006C                     1226  	;***      513 :  * Function Name: r_uart3_callback_error
0000006C                     1227  	;***      514 :  * Description  : This function is a callback function when UART3 reception error occurs.
0000006C                     1228  	;***      515 :  * Arguments    : err_type -
0000006C                     1229  	;***      516 :  *                    error type value
0000006C                     1230  	;***      517 :  * Return Value : None
0000006C                     1231  	;***      518 :  ***********************************************************************************************************************/
0000006C                     1232  	;***      519 : static void r_uart3_callback_error(uint8_t err_type) {
0000006C                     1233  	.LINE "D:/Chieniwa/E2_Studio/ControlPCB_HWM/src/r_cg_serial_user.c", 519
0000006C D7                  1234  	ret
0000006D                     1235  	;***      520 : 	/* Start user code. Do not edit comment generated here */
0000006D                     1236  	;***      521 : 	/* End user code. Do not edit comment generated here */
0000006D                     1237  	;***      522 : }
0000006D                     1238  	;***      523 : 
0000006D                     1239  	;***      524 : /* Start user code for adding. Do not edit comment generated here */
0000006D                     1240  	;***      525 : /* End user code. Do not edit comment generated here */
00000000                     1241  	.SECTION .bss,BSS
00000000                     1242  _g_uart3_rx_data:
00000000                     1243  	.DS (8)
00000008                     1244  _send_response_flag:
00000008                     1245  	.DS (1)
00000009                     1246  _send_response_time_flag:
00000009                     1247  	.DS (1)
0000000A                     1248  _send_response_number_flag:
0000000A                     1249  	.DS (1)
0000000B                     1250  _recived_time_setting_flag:
0000000B                     1251  	.DS (1)
0000000C                     1252  _send_respone_status_flag:
0000000C                     1253  	.DS (1)
0000000D                     1254  _recived_number_setting_flag:
0000000D                     1255  	.DS (1)
0000000E                     1256  _g_commnunication_flag:
0000000E                     1257  	.DS (16)
0000001E                     1258  _g_csi_count:
0000001E                     1259  	.DS (1)
0000001F                     1260  _g_csi_err:
0000001F                     1261  	.DS (1)
00000020                     1262  _g_csi_send_end:
00000020                     1263  	.DS (1)
00000021                     1264  _g_csi_rev_end:
00000021                     1265  	.DS (1)
00000022                     1266  _g_uart1_send:
00000022                     1267  	.DS (1)
00000023                     1268  _g_uart2_sendend:
00000023                     1269  	.DS (1)
00000024                     1270  _g_uart2_receive:
00000024                     1271  	.DS (1)
00000025                     1272  _g_rx_data:
00000025                     1273  	.DS (160)
000000C5                     1274  _g_uart2_fault:
000000C5                     1275  	.DS (1)
000000C6                     1276  _g_uart3_sendend:
000000C6                     1277  	.DS (1)

Section List
Attr     Size                Name

TEXT                638 (0000027E) .text
TEXTF               109 (0000006D) .textf
BSS                 199 (000000C7) .bss

Command Line Parameter
Files (x86)\Renesas Electronics\CS+\CC\CC-RL\V1.10.00\bin\asrl.exe" @C:\Users\CODEP~1\AppData\Local\Temp\$ccrl000\r_cg_serial_user.asm.cmd 

Command File Parameter
-cpu=S3 -dev=D:\Chieniwa\E2_Studio\.eclipse\com.renesas.platform_1435879475\DebugComp\RL78\RL78\Common\DR5F104ML.DVF -define=__RENESAS_VERSION__=0x01100000 -include="C:\Program Files (x86)\Renesas Electronics\CS+\CC\CC-RL\V1.10.00\inc" -include=D:\Chieniwa\E2_Studio\ControlPCB_HWM\generate -character_set=utf8 -prn_path=src -output=D:\Chieniwa\E2_Studio\ControlPCB_HWM\HardwareDebug\src\r_cg_serial_user.obj D:\Chieniwa\E2_Studio\ControlPCB_HWM\HardwareDebug\src\r_cg_serial_user.asm 

